var U=Object.defineProperty;var q=(e,t,n)=>t in e?U(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var m=(e,t,n)=>q(e,typeof t!="symbol"?t+"":t,n);import{x as g,L as B,n as k,M as R,l as K,N as L,O as Q,P as C,E as N,Q as T,A as P,R as W,S as X,T as Y,U as Z,V as z,W as F,X as G,Y as H,Z as J,_ as ee,$ as te}from"./BYLBfqqe.js";const O=new Set;let v;function le(){v={r:0,c:[],p:v}}function _e(){v.r||g(v.c),v=v.p}function V(e,t){e&&e.i&&(O.delete(e),e.i(t))}function ne(e,t,n,s){if(e&&e.o){if(O.has(e))return;O.add(e),v.c.push(()=>{O.delete(e),s&&(n&&e.d(1),s())}),e.o(t)}else s&&s()}function se(e){return(e==null?void 0:e.length)!==void 0?e:Array.from(e)}function $e(e,t){ne(e,1,1,()=>{t.delete(e.key)})}function he(e,t,n,s,o,r,f,d,l,a,w,_){let c=e.length,$=r.length,u=c;const M={};for(;u--;)M[e[u].key]=u;const S=[],E=new Map,D=new Map,j=[];for(u=$;u--;){const i=_(o,r,u),h=n(i);let y=f.get(h);y?j.push(()=>y.p(i,t)):(y=a(h,i),y.c()),E.set(h,S[u]=y),h in M&&D.set(h,Math.abs(u-M[h]))}const A=new Set,I=new Set;function b(i){V(i,1),i.m(d,w),f.set(i.key,i),w=i.first,$--}for(;c&&$;){const i=S[$-1],h=e[c-1],y=i.key,x=h.key;i===h?(w=i.first,c--,$--):E.has(x)?!f.has(y)||A.has(y)?b(i):I.has(x)?c--:D.get(y)>D.get(x)?(I.add(y),b(i)):(A.add(x),c--):(l(h,f),c--)}for(;c--;){const i=e[c];E.has(i.key)||l(i,f)}for(;$;)b(S[$-1]);return g(j),S}function ye(e,t,n,s){const o=new Map;for(let r=0;r<t.length;r++){const f=s(n(e,t,r));if(o.has(f)){let d="";try{d=`with value '${String(f)}' `}catch{}throw new Error(`Cannot have duplicate keys in a keyed each: Keys at index ${o.get(f)} and ${r} ${d}are duplicates`)}o.set(f,r)}}function pe(e){e&&e.c()}function ve(e,t){e&&e.l(t)}function oe(e,t,n){const{fragment:s,after_update:o}=e.$$;s&&s.m(t,n),P(()=>{const r=e.$$.on_mount.map(X).filter(N);e.$$.on_destroy?e.$$.on_destroy.push(...r):g(r),e.$$.on_mount=[]}),o.forEach(P)}function ae(e,t){const n=e.$$;n.fragment!==null&&(W(n.after_update),g(n.on_destroy),n.fragment&&n.fragment.d(t),n.on_destroy=n.fragment=null,n.ctx=[])}function ie(e,t){e.$$.dirty[0]===-1&&(z.push(e),F(),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}function we(e,t,n,s,o,r,f=null,d=[-1]){const l=B;C(e);const a=e.$$={fragment:null,ctx:[],props:r,update:k,not_equal:o,bound:R(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(t.context||(l?l.$$.context:[])),callbacks:R(),dirty:d,skip_bound:!1,root:t.target||l.$$.root};f&&f(a.root);let w=!1;if(a.ctx=n?n(e,t.props||{},(_,c,...$)=>{const u=$.length?$[0]:c;return a.ctx&&o(a.ctx[_],a.ctx[_]=u)&&(!a.skip_bound&&a.bound[_]&&a.bound[_](u),w&&ie(e,_)),c}):[],a.update(),w=!0,g(a.before_update),a.fragment=s?s(a.ctx):!1,t.target){if(t.hydrate){Y();const _=K(t.target);a.fragment&&a.fragment.l(_),_.forEach(L)}else a.fragment&&a.fragment.c();t.intro&&V(e.$$.fragment),oe(e,t.target,t.anchor),Z(),Q()}C(l)}class re{constructor(){m(this,"$$");m(this,"$$set")}$destroy(){ae(this,1),this.$destroy=k}$on(t,n){if(!N(n))return k;const s=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return s.push(n),()=>{const o=s.indexOf(n);o!==-1&&s.splice(o,1)}}$set(t){this.$$set&&!T(t)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}const fe="4.2.20",de="4";function p(e,t){document.dispatchEvent(G(e,{version:fe,...t},{bubbles:!0}))}function me(e,t){p("SvelteDOMInsert",{target:e,node:t}),J(e,t)}function ge(e,t,n){p("SvelteDOMInsert",{target:e,node:t,anchor:n}),H(e,t,n)}function Se(e){p("SvelteDOMRemove",{node:e}),L(e)}function xe(e,t,n,s,o,r,f){const d=s===!0?["capture"]:s?Array.from(Object.keys(s)):[];o&&d.push("preventDefault"),r&&d.push("stopPropagation"),f&&d.push("stopImmediatePropagation"),p("SvelteDOMAddEventListener",{node:e,event:t,handler:n,modifiers:d});const l=te(e,t,n,s);return()=>{p("SvelteDOMRemoveEventListener",{node:e,event:t,handler:n,modifiers:d}),l()}}function Oe(e,t,n){ee(e,t,n),n==null?p("SvelteDOMRemoveAttribute",{node:e,attribute:t}):p("SvelteDOMSetAttribute",{node:e,attribute:t,value:n})}function Me(e,t,n){e[t]=n,p("SvelteDOMSetProperty",{node:e,property:t,value:n})}function Ee(e,t){t=""+t,e.data!==t&&(p("SvelteDOMSetData",{node:e,data:t}),e.data=t)}function De(e){if(typeof e!="string"&&!(e&&typeof e=="object"&&"length"in e)&&!(typeof Symbol=="function"&&e&&Symbol.iterator in e))throw new Error("{#each} only works with iterable values.");return se(e)}function be(e,t,n){for(const s of Object.keys(t))~n.indexOf(s)||console.warn(`<${e}> received an unexpected slot "${s}".`)}function ke(e,t){const n="this={...} of <svelte:component> should specify a Svelte component.";try{const s=new e(t);if(!s.$$||!s.$set||!s.$on||!s.$destroy)throw new Error(n);return s}catch(s){const{message:o}=s;throw typeof o=="string"&&o.indexOf("is not a constructor")!==-1?new Error(n):s}}class je extends re{constructor(n){if(!n||!n.target&&!n.$$inline)throw new Error("'target' is a required option");super();m(this,"$$prop_def");m(this,"$$events_def");m(this,"$$slot_def")}$destroy(){super.$destroy(),this.$destroy=()=>{console.warn("Component was already destroyed")}}$capture_state(){}$inject_state(){}}typeof window<"u"&&(window.__svelte||(window.__svelte={v:new Set})).v.add(de);export{je as S,V as a,Se as b,Oe as c,p as d,De as e,ge as f,me as g,ke as h,we as i,le as j,_e as k,xe as l,ae as m,pe as n,oe as o,Me as p,ve as q,ye as r,Ee as s,ne as t,he as u,be as v,$e as w};
